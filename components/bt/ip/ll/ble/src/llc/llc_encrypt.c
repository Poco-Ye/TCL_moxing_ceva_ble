/**
 ****************************************************************************************
 *
 * @file llc_encrypt.c
 *
 * @brief Handles the Pause Encryption and Encryption Start procedures.
 *
 * Copyright (C) RivieraWaves 2009-2016
 *
 ****************************************************************************************
 */


/**
 ****************************************************************************************
 * @addtogroup LLC_ENCRYPT
 * @{
 ****************************************************************************************
 */

/*
 * INCLUDE FILES
 ****************************************************************************************
 */

#include "rwip_config.h"

#if (BLE_CENTRAL || BLE_PERIPHERAL)
#include <stdint.h>
#include <stdbool.h>
#include <string.h>

#include "co_utils.h"    // For bit field manipulation

#include "ke_msg.h"      // Kernel message

#include "llc.h"        // LLC API
#include "llc_int.h"    // Internal LLC API
#include "llc_llcp.h"   // Internal LLCP API

#include "lld.h"        // For flow control
#include "hci.h"        // For HCI handler
#include "llm.h"        // For Feature mask check
#include "aes.h"        // For encrypt functions

#if (BLE_CIS)
#include "lli.h"        // Isochronous
#endif // (BLE_CIS)


/*
 * TYPE DEFINITIONS
 ****************************************************************************************
 */

/// Encryption operation indication structure definition
struct llc_op_encrypt_ind
{
    /// Procedure information
    llc_procedure_t                 proc;
    /// Random number - 8B
    struct rand_nb                  nb;
    /// LTK or Session Key (according to procedure state)
    struct ltk                      key;
    /// Initialization Vector
    struct initialization_vector    iv;
    /// Session Key Diversifier
    struct sess_k_div               skd;
    /// Encryption Diversifier
    uint16_t                        enc_div;
    /// Encrypt or Re-encrypt link
    bool                            re_encrypt;
};



/*
 * DEFINES
 ****************************************************************************************
 */
/*@TRACE*/
enum llc_encrypt_state
{
    // Local Encryption Procedure state machine (Master only)
    /// Start Pause Encryption
    LLC_LOC_ENC_PROC_START,

    // -- Pause encryption
    /// Encryption pause procedure is ongoing
    LLC_LOC_WAIT_PAUSE_ENC_RSP,
    /// Wait for pause response to be sent
    LLC_LOC_WAIT_PAUSE_ENC_RSP_ACK,

    // -- Encryption start
    /// Wait for IVm SKDm generation
    LLC_LOC_WAIT_IVM_SKDM_GEN,
    /// Wait for encryption response
    LLC_LOC_WAIT_ENC_RSP,
    /// Wait for start encryption request
    LLC_LOC_WAIT_START_ENC_REQ,
    /// Wait for Session Key generated by HW AES engine
    LLC_LOC_WAIT_SK,
    /// ready to send start encryption response
    LLC_LOC_SEND_START_ENC_RSP,
    /// wait for start encryption response from slave
    LLC_LOC_WAIT_START_ENC_RSP,

    /// Local encryption error state
    LLC_LOC_ENC_ERROR,

    //Remote Encryption Procedure state machine (Slave only)
    /// Start Pause Encryption
    LLC_REM_ENC_PROC_START,
    /// Wait for pause encryption response to be received
    LLC_REM_WAIT_PAUSE_ENC_RSP,
    /// Wait for encryption  request to be received
    LLC_REM_WAIT_ENC_REQ,

    /// Wait for IVs SKDs generation
    LLC_REM_WAIT_IVS_SKDS_GEN,
    /// Wait for LTK from host
    LLC_REM_WAIT_LTK,
    /// Wait for Session Key generated by HW AES engine
    LLC_REM_WAIT_SK,
    /// Wait for start encryption response
    LLC_REM_WAIT_START_ENC_RSP,
    /// Wait for TX Ack Response
    LLC_REM_WAIT_START_ENC_RSP_ACK,

    /// Wait for Encryption reject Ack Response
    LLC_REM_WAIT_ENC_REJECT_ACK,

    /// Local encryption error state
    LLC_REM_ENC_ERROR,
};

/*
 * MACROS
 ****************************************************************************************
 */


/*
 * GLOBAL VARIABLE DEFINITIONS
 ****************************************************************************************
 */

/*
 * LOCAL FUNCTIONS DECLARATIONS
 ****************************************************************************************
 */
__STATIC void llc_loc_encrypt_proc_continue(uint8_t link_id, uint8_t state, uint8_t status);
__STATIC void llc_rem_encrypt_proc_continue(uint8_t link_id, uint8_t state, uint8_t status);
__STATIC void llc_iv_skd_rand_gen(uint8_t link_id);
__STATIC void llc_sk_gen(uint8_t link_id, struct ltk* ltk,  struct sess_k_div *skd);
__STATIC void llc_ll_pause_enc_req_pdu_send(uint8_t link_id);
__STATIC void llc_ll_pause_enc_rsp_pdu_send(uint8_t link_id, llc_llcp_tx_cfm_cb cfm_cb);
__STATIC void llc_ll_enc_req_pdu_send(uint8_t link_id, uint16_t ediv, uint8_t* rand, uint8_t* skdm, uint8_t* ivm);
__STATIC void llc_ll_enc_rsp_pdu_send(uint8_t link_id, uint8_t* skds, uint8_t* ivs);
__STATIC void llc_ll_start_enc_req_pdu_send(uint8_t link_id);
__STATIC void llc_ll_start_enc_rsp_pdu_send(uint8_t link_id, llc_llcp_tx_cfm_cb cfm_cb);

__STATIC void llc_ll_pause_enc_rsp_ack_handler(uint8_t link_id, uint8_t op_code);
__STATIC void llc_ll_start_enc_rsp_ack_handler(uint8_t link_id, uint8_t op_code);
__STATIC void llc_ll_reject_ind_ack_handler(uint8_t link_id, uint8_t op_code);

__STATIC void llc_hci_ltk_request_evt_send(uint8_t link_id, uint16_t enc_div, uint8_t* randnb);
__STATIC void llc_hci_enc_evt_send(uint8_t link_id, uint8_t status, bool re_encrypt);

__STATIC void llc_ll_reject_ind_ack_handler(uint8_t link_id, uint8_t op_code);

__STATIC void llc_loc_encrypt_proc_err_cb(uint8_t link_id, uint8_t error_type, void* param);
__STATIC void llc_rem_encrypt_proc_err_cb(uint8_t link_id, uint8_t error_type, void* param);

/*
 * LOCAL FUNCTIONS DEFINITIONS
 ****************************************************************************************
 */

/**
 ****************************************************************************************
 * Continue execution of local procedure
 *
 * @param[in] link_id Link identifier
 * @param[in] state   Expected state of the procedure
 * @param[in] status  Status of the operation
 ****************************************************************************************
 */
__STATIC void llc_loc_encrypt_proc_continue(uint8_t link_id, uint8_t state, uint8_t status)
{
    /// Gets the LLC environment dedicated to this link
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    /// retrieve procedure parameters
    struct llc_op_encrypt_ind* param = (struct llc_op_encrypt_ind*) llc_proc_get(link_id, LLC_PROC_LOCAL);
    bool finished = false;
    uint8_t proc_state = llc_proc_state_get(&param->proc);

    // check that current procedure state equals to expected state given in parameter
    if(proc_state != state)
    {
        // procedure Negotiation fails with negotiation issue
        if(state != LLC_LOC_ENC_ERROR)
        {
            status = CO_ERROR_TERMINATED_MIC_FAILURE;
        }
        else
        {
            // check error status
            switch(status)
            {
                case CO_ERROR_REMOTE_USER_TERM_CON:
                case CO_ERROR_LMP_RSP_TIMEOUT:
                case CO_ERROR_CON_TIMEOUT:
                {
                     // nothing to do / keep error code
                }
                break;
                case CO_ERROR_PIN_MISSING:
                {
                    if(proc_state == LLC_LOC_WAIT_START_ENC_REQ)
                    {
                        // nothing to do / keep error code
                        break;
                    }
                }
                // no break
                case CO_ERROR_UNSUPPORTED_REMOTE_FEATURE:
                {
                    if(proc_state == LLC_LOC_WAIT_ENC_RSP)
                    {
                        // nothing to do / keep error code
                        break;
                    }

                }
                // no break
                default:
                {
                    // not expected by standard force MIC failure
                    status = CO_ERROR_TERMINATED_MIC_FAILURE;
                }break;
            }
        }

        // unexpected behavior detected, try to disconnect anyway
        if(status == CO_ERROR_TERMINATED_MIC_FAILURE)
        {
            llc_disconnect(link_id, status, true);
        }

        finished = true;
    }
    else
    {
        switch(proc_state)
        {
            /*
             * @startuml
             * title : Encryption procedure start (ENC_PROC_START)
             * participant LLM
             * participant LLC
             * participant LLD
             * LLC -> LLC: llc_loc_encrypt_proc_continue(START)
             * activate LLC
             *     LLC -> LLD: lld_con_data_flow_set(off)
             *     alt Pause Encryption Procedure
             *         LLC --> LLD : LLCP_PAUSE_ENC_REQ
             *         hnote over LLC #aqua: state = WAIT_PAUSE_ENC_RSP
             *     else  Encryption Start Procedure
             *         hnote over LLC #aqua: state = WAIT_IVM_SKDM_GEN
             *         note over LLC : Use HW AES to generate IVm and SKDm
             *         LLC --> LLM : LLM_ENCRYPT_REQ
             *     end
             * deactivate LLC
             * @enduml
             */
             case LLC_LOC_ENC_PROC_START:
             {
                 // stop tx flow
                 lld_con_data_flow_set(link_id, false);

                 if(param->re_encrypt)
                 {
                     // send LLCP_PAUSE_ENC_REQ pdu
                     llc_ll_pause_enc_req_pdu_send(link_id);
                     // Wait for Pause encryption response
                     llc_proc_state_set(&param->proc, link_id, LLC_LOC_WAIT_PAUSE_ENC_RSP);
                     // Block transmission of LLCPs that are not allowed during encryption pause
                     llc_llcp_state_set(link_id, LLC_LLCP_DIR_TX, LLC_LLCP_PAUSE_ENC);
                 }
                 else
                 {
                     // Generate IVm + SKDm
                     llc_iv_skd_rand_gen(link_id);
                     // wait for IVm and SKDm generation
                     llc_proc_state_set(&param->proc, link_id, LLC_LOC_WAIT_IVM_SKDM_GEN);
                 }
             } break;

             /*
              * @startuml
              * title : Pause Enc Response (WAIT_PAUSE_ENC_RSP)
              * participant LLC
              * participant LLD
              * LLD --> LLC: LLCP_PAUSE_ENC_RSP
              * LLC -> LLC: ll_pause_enc_rsp_handler()
              * activate LLC
              *     LLC -> LLC: llc_loc_encrypt_proc_continue(PAUSE_ENC_RSP)
              *     activate LLC
              *         note over LLC: Stop encryption
              *         LLC -> LLD:  lld_con_rx_enc(off)
              *         LLC -> LLD:  lld_con_tx_enc(off)
              *         hnote over LLC #aqua: state = WAIT_FOR_PAUSE_ENC_ACK
              *         LLC --> LLD : LLCP_PAUSE_ENC_RSP
              *     deactivate LLC
              * deactivate LLC
              * @enduml
              */
             case LLC_LOC_WAIT_PAUSE_ENC_RSP:
             {
                 // Block reception of LLCPs that are not allowed during encryption pause
                 llc_llcp_state_set(link_id, LLC_LLCP_DIR_RX, LLC_LLCP_PAUSE_ENC);

                 // pause remote procedure
                 llc_proc_timer_pause_set(link_id, LLC_PROC_REMOTE, true);

                 // start local LLCP exchange Timer
                 llc_proc_timer_set(link_id, LLC_PROC_LOCAL, false);

                 // stop link encryption
                 lld_con_rx_enc(link_id, false);
                 lld_con_tx_enc(link_id, false);

                 // send LLCP_PAUSE_ENC_RSP pdu
                 llc_ll_pause_enc_rsp_pdu_send(link_id, llc_ll_pause_enc_rsp_ack_handler);
                 // Wait for Pause encryption response ACK
                 llc_proc_state_set(&param->proc, link_id, LLC_LOC_WAIT_PAUSE_ENC_RSP_ACK);
             } break;

             /*
              * @startuml
              * title : Pause Enc Response ACK (WAIT_PAUSE_ENC_RSP_ACK)
              * participant LLM
              * participant LLC_LLCP
              * participant LLC
              * participant LLD
              * LLD --> LLC_LLCP: LLD_LLCP_TX_CFM
              * LLC_LLCP -> LLC_LLCP: lld_llcp_tx_cfm_handler()
              * activate LLC_LLCP
              *     LLC_LLCP -> LLC: ll_pause_enc_rsp_ack_handler()
              *     activate LLC
              *         LLC -> LLC: llc_loc_encrypt_proc_continue(PAUSE_ENC_RSP_ACK)
              *         activate LLC
              *             hnote over LLC #aqua: state = WAIT_IVM_SKDM_GEN
              *             note over LLC : Use HW AES to generate IVm and SKDm
              *             LLC --> LLM : LLM_ENCRYPT_REQ
              *         deactivate LLC
              *     deactivate LLC
              * deactivate LLC_LLCP
              * @enduml
              */
             case LLC_LOC_WAIT_PAUSE_ENC_RSP_ACK:
             {
                 // Generate IVm + SKDm
                 llc_iv_skd_rand_gen(link_id);
                 // wait for IVm and SKDm generation
                 llc_proc_state_set(&param->proc, link_id, LLC_LOC_WAIT_IVM_SKDM_GEN);
             } break;

             /*
              * @startuml
              * title : IVm & SKDm generated (WAIT_IVM_SKDM_GEN)
              * participant LLM
              * participant LLC
              * participant LLD
              * LLM--> LLC: LLM_ENCRYPT_RSP
              * LLC -> LLC: llm_encrypt_rsp_handler()
              * note over LLC: Store computed IVm and SKDm
              * activate LLC
              *     LLC -> LLC: llc_loc_encrypt_proc_continue(IVM_SKDM_GEN)
              *     activate LLC
              *         LLC --> LLD : LLCP_ENC_REQ(RandNB, Ediv, IVm, SKDm)
              *         hnote over LLC #aqua: state = WAIT_FOR_ENC_RSP
              *     deactivate LLC
              * deactivate LLC
              * @enduml
              */
             case LLC_LOC_WAIT_IVM_SKDM_GEN:
             {
                 // send encryption request
                 llc_ll_enc_req_pdu_send(link_id, param->enc_div, &(param->nb.nb[0]), &(param->skd.skd[SKD_M_OFFSET]),
                         &(param->iv.vect[IV_M_OFFSET]));
                 // Wait for encryption response
                 llc_proc_state_set(&param->proc, link_id, LLC_LOC_WAIT_ENC_RSP);

                 // start local LLCP exchange Timer
                 llc_proc_timer_set(link_id, LLC_PROC_LOCAL, true);

                 if(param->re_encrypt)
                 {
                     // Block reception and transmission of LLCPs that are not allowed during encryption start
                     llc_llcp_state_set(link_id, LLC_LLCP_DIR_BOTH, LLC_LLCP_START_ENC);
                 }
                 else
                 {
                     // Block transmission of LLCPs that are not allowed during encryption start
                     llc_llcp_state_set(link_id, LLC_LLCP_DIR_TX, LLC_LLCP_START_ENC);
                 }
             } break;

             /*
             * @startuml
             * title : Encryption procedure start (WAIT_ENC_RSP)
             * participant LLM
             * participant LLC
             * participant LLD
             * LLC -> LLC: llc_loc_encrypt_proc_continue(ENC_RSP)
             * activate LLC
             *     hnote over LLC #aqua: state = WAIT_START_ENC_REQ
             * deactivate LLC
             * @enduml
              */
             case LLC_LOC_WAIT_ENC_RSP:
             {
                 // Block reception of LLCPs that are not allowed during encryption start
                 llc_llcp_state_set(link_id, LLC_LLCP_DIR_RX, LLC_LLCP_START_ENC);

                 // pause remote procedure
                 llc_proc_timer_pause_set(link_id, LLC_PROC_REMOTE, true);

                 // Wait for SK computation and Start encryption response
                 llc_proc_state_set(&param->proc, link_id, LLC_LOC_WAIT_START_ENC_REQ);
                 // restart local LLCP exchange Timer
                 llc_proc_timer_set(link_id, LLC_PROC_LOCAL, true);
             } break;


             /*
              * @startuml
              * title : Wait for SK and Start Enc Request (WAIT_START_ENC_REQ)
              * participant LLM
              * participant LLC
              * participant LLD
              * LLD --> LLC: LLCP_START_ENC_REQ
              * LLC -> LLC: ll_start_enc_req_handler()
              * activate LLC
              *     hnote over LLC #aqua: state = WAIT_SK
              *     note over LLC : Use HW AES to compute Session key
              *     LLC --> LLM : LLM_ENCRYPT_REQ
              * deactivate LLC
              * @enduml
              */
             case LLC_LOC_WAIT_START_ENC_REQ:
             {
                 // Generate session key using LTK and session key diversifier [SKDm, SKDs]
                 llc_sk_gen(link_id, &(param->key), &(param->skd));
                 // Wait for SK computation and Start encryption response
                 llc_proc_state_set(&param->proc, link_id, LLC_LOC_WAIT_SK);
                 // clear local LLCP exchange Timer
                 llc_proc_timer_set(link_id, LLC_PROC_LOCAL, false);
             } break;

             /*
              * @startuml
              * title : Wait for SK (WAIT_SK)
              * participant LLM
              * participant LLC
              * participant LLD
              * LLM --> LLC: LLM_ENCRYPT_RSP
              * LLC -> LLC: llm_encrypt_rsp_handler()
              * activate LLC
              *     note over LLC : Store computed Session key
              *     LLC -> LLC: llc_loc_encrypt_proc_continue(WAIT_SK)
              *     activate LLC
              *     LLC -> LLD:  lld_con_enc_key_load(SK, IV)
              *     LLC -> LLD:  lld_con_rx_enc(on)
              *     LLC -> LLD:  lld_con_tx_enc(on)
              *     hnote over LLC #aqua: state = WAIT_START_ENC_RSP
              *     LLC --> LLD: LLCP_START_ENC_RSP
              *     deactivate LLC
              * deactivate LLC
              * @enduml
              */
             case LLC_LOC_WAIT_SK:
             {
                 // Load encryption information
                 lld_con_enc_key_load(link_id, &(param->key), &(param->iv));
                 // Start TX / RX Encryption flow
                 lld_con_rx_enc(link_id, true);
                 lld_con_tx_enc(link_id, true);

                 // Send LLCP_START_ENC_RSP PDU
                 llc_ll_start_enc_rsp_pdu_send(link_id, NULL);
                 // Wait for LLCP_START_ENC_RSP PDU
                 llc_proc_state_set(&param->proc, link_id, LLC_LOC_WAIT_START_ENC_RSP);
                 // start local LLCP exchange Timer
                 llc_proc_timer_set(link_id, LLC_PROC_LOCAL, true);

                 // Encryption start procedure started
                 SETB(llc_env_ptr->link_info, LLC_INFO_ENC_START, true);

             } break;


             /*
              * @startuml
              * title : Wait for Start Enc Response (WAIT_START_ENC_RSP)
              * participant HCI
              * participant LLC
              * participant LLD
              * LLD --> LLC: LLCP_START_ENC_RSP
              * LLC -> LLC: ll_start_enc_rsp_handler()
              * activate LLC
              *     LLC -> LLC: llc_loc_encrypt_proc_continue(START_ENC_RSP)
              *     activate LLC
              *     note over LLC: Encryption procedure is finished
              *     LLC -> LLD: lld_con_data_flow_set(on)
              *     hnote over LLC : LOC_PROC = Busy
              *     alt First encryption
              *         LLC --> HCI: HCI_ENC_CHG_EVT
              *     else Re-Encryption
              *         LLC --> HCI: HCI_ENC_KEY_REFRESH_CMP_EVT
              *     end
              *     deactivate LLC
              * deactivate LLC
              * @enduml
              */
             case LLC_LOC_WAIT_START_ENC_RSP:
             {
                 // clear local LLCP exchange Timer
                 llc_proc_timer_set(link_id, LLC_PROC_LOCAL, false);
                 finished = true;
             } break;

            default:
            {
                status = CO_ERROR_UNSPECIFIED_ERROR;
                ASSERT_INFO(0, link_id, proc_state);
            }
            break;
        }
    }

    if(finished)
    {
        // in case link can be continued
        if(!llc_is_disconnecting(link_id))
        {
            // Mark Encryption procedure finished
            SETB(llc_env_ptr->flow_ctrl, LLC_HCI_START_ENCRYPT_REQ, false);
            // Restore the Data Flow
            lld_con_data_flow_set(link_id, true);

            // Re-enable reception and transmission of all LLCPs
            llc_llcp_state_set(link_id, LLC_LLCP_DIR_BOTH, LLC_LLCP_IDLE);

            // resume remote procedure
            llc_proc_timer_pause_set(link_id, LLC_PROC_REMOTE, false);

            // mark link encrypted or not
            SETB(llc_env_ptr->link_info, LLC_INFO_LINK_ENCRYPTED, (status == CO_ERROR_NO_ERROR));

            // Start the LE_PING feature
            llc_le_ping_restart(link_id);
        }

        // Send HCI_ENC_CHG_EVT or HCI_ENC_KEY_REFRESH_CMP_EVT
        llc_hci_enc_evt_send(link_id, status, param->re_encrypt);

        // unregister procedure
        llc_proc_unreg(link_id, LLC_PROC_LOCAL);

        // Encryption start procedure finished
        SETB(llc_env_ptr->link_info, LLC_INFO_ENC_START, false);
    }
}



/**
 ****************************************************************************************
 * Continue execution of remote procedure
 *
 * @param[in] link_id Link identifier
 * @param[in] state   Expected state of the procedure
 * @param[in] status  Status of the operation
 ****************************************************************************************
 */
__STATIC void llc_rem_encrypt_proc_continue(uint8_t link_id, uint8_t state, uint8_t status)
{
    /// Gets the LLC environment dedicated to this link
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    /// retrieve procedure parameters
    struct llc_op_encrypt_ind* param = (struct llc_op_encrypt_ind*) llc_proc_get(link_id, LLC_PROC_REMOTE);
    bool finished = false;

    // check that current procedure state equals to expected state given in parameter
    if(llc_proc_state_get(&param->proc) != state)
    {
        // procedure Negotiation fails with negotiation issue
        if(state != LLC_REM_ENC_ERROR)
        {
            status = CO_ERROR_TERMINATED_MIC_FAILURE;
        }
        // else nothing to do

        // unexpected behavior detected, try to disconnect anyway
        if(status == CO_ERROR_TERMINATED_MIC_FAILURE)
        {
            llc_disconnect(link_id, status, true);
        }

        finished = true;
    }
    else
    {
        switch(llc_proc_state_get(&param->proc))
        {
            /*
             * @startuml
             * title : Encryption procedure start,\n initiated by peer(ENC_PROC_START)
             * participant LLM
             * participant LLC
             * participant LLD
             * alt Encryption procedure requested
             *     LLD --> LLC: LLCP_ENC_REQ
             *     LLC -> LLC: ll_enc_req_handler()
             *     activate LLC
             *         note over LLC: Allocate new remote procedure data info
             *         note over LLC: Mark procedure started
             *         note over LLC: Store RandNB, Ediv, IVm and SKDm
             *         LLC -> LLC: llc_rem_encrypt_proc_continue(START)
             *         activate LLC
             *             LLC -> LLD: lld_con_data_flow_set(off)
             *             hnote over LLC #aqua: state = WAIT_IVS_SKDS_GEN
             *             note over LLC : Use HW AES to generate IVs and SKDs
             *             LLC --> LLM : LLM_ENCRYPT_REQ
             *         deactivate LLC
             *     deactivate LLC
             * else Re-encryption procedure requested
             *     LLD --> LLC: LLCP_PAUSE_ENC_REQ
             *     LLC -> LLC: ll_pause_enc_req_handler()
             *     activate LLC
             *         note over LLC: Allocate new remote procedure data info
             *         note over LLC: Mark procedure started
             *         LLC -> LLC: llc_rem_encrypt_proc_continue(START)
             *         activate LLC
             *             note over LLC: Stop RX encryption
             *             LLC -> LLD:  lld_con_rx_enc(off)
             *             hnote over LLC #aqua: state = WAIT_PAUSE_ENC_RSP
             *             LLC --> LLD : LLCP_PAUSE_ENC_RSP()
             *         deactivate LLC
             *     deactivate LLC
             * end
             * @enduml
             */
            case LLC_REM_ENC_PROC_START:
            {
                // Fist stop the ACL Flow
                lld_con_data_flow_set(link_id, false);
                // pause local procedure timer and so local procedure
                llc_proc_timer_pause_set(link_id, LLC_PROC_LOCAL, true);

                // check that re_encrypt is expected or not.
                if(param->re_encrypt != GETB(llc_env_ptr->link_info, LLC_INFO_LINK_ENCRYPTED))
                {
                    // send LLCP_REJECT_IND[_EXT] PDU
                    llc_ll_reject_ind_pdu_send(link_id, LL_ENC_REQ_OPCODE, CO_ERROR_LMP_PDU_NOT_ALLOWED,
                                                llc_ll_reject_ind_ack_handler);
                    // Wait for PDU ACK
                    llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_ENC_REJECT_ACK);
                }
                // Encryption Start procedure
                if(!param->re_encrypt)
                {
                    // Change connection state to Pause encryption to control TX/RX packets
                    llc_llcp_state_set(link_id, LLC_LLCP_DIR_BOTH, LLC_LLCP_START_ENC);
                    // Generate IVs + SKDs
                    llc_iv_skd_rand_gen(link_id);
                    // wait for IVs and SKDs generation
                    llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_IVS_SKDS_GEN);
                }
                // Pause Encryption procedure
                else
                {
                    // Disable RX Encryption
                    lld_con_rx_enc(link_id, false);
                    // Change connection state to Pause encryption to control TX/RX packets
                    llc_llcp_state_set(link_id, LLC_LLCP_DIR_BOTH, LLC_LLCP_PAUSE_ENC);

                    // send LLCP_PAUSE_ENC_RSP pdu
                    llc_ll_pause_enc_rsp_pdu_send(link_id, NULL);
                    // Wait for Pause encryption response
                    llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_PAUSE_ENC_RSP);

                    // start remote LLCP exchange Timer
                    llc_proc_timer_set(link_id, LLC_PROC_REMOTE, true);
                }
            } break;

            /*
             * @startuml
             * title : Pause encryption procedure(WAIT_PAUSE_ENC_RSP)
             * participant LLC
             * participant LLD
             * LLD --> LLC: LLCP_PAUSE_ENC_RSP
             * LLC -> LLC: ll_pause_enc_rsp_handler()
             * activate LLC
             *     LLC -> LLC: llc_rem_encrypt_proc_continue(PAUSE_ENC_RSP)
             *     activate LLC
             *         hnote over LLC #aqua: state = WAIT_ENC_REQ
             *         note over LLC: Stop TX encryption
             *         LLC -> LLD:  lld_con_tx_enc(off)
             *     deactivate LLC
             * deactivate LLC
             * @enduml
             */
            case LLC_REM_WAIT_PAUSE_ENC_RSP:
            {
                // Disable TX Encryption
                lld_con_tx_enc(link_id, false);
                // Wait for Pause encryption response
                llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_ENC_REQ);
                // re-start remote LLCP exchange Timer
                llc_proc_timer_set(link_id, LLC_PROC_REMOTE, true);
            } break;

            /*
             * @startuml
             * title : IVs & SKDs generated (WAIT_ENC_REQ)
             * participant LLM
             * participant LLC
             * participant LLD
             * LLD --> LLC: LLCP_ENC_REQ
             * LLC -> LLC: ll_enc_req_handler()
             * note over LLC: Store RandNB, Ediv, IVm and SKDm
             * activate LLC
             *     LLC -> LLC: llc_rem_encrypt_proc_continue(ENC_REQ)
             *     activate LLC
             *         hnote over LLC #aqua: state = WAIT_IVS_SKDS_GEN
             *         note over LLC : Use HW AES to generate IVs and SKDs
             *         LLC --> LLM : LLM_ENCRYPT_REQ
             *     deactivate LLC
             * deactivate LLC
             * @enduml
             */
            case LLC_REM_WAIT_ENC_REQ:
            {
                // Change connection state to Pause encryption to control TX/RX packets
                llc_llcp_state_set(link_id, LLC_LLCP_DIR_BOTH, LLC_LLCP_START_ENC);
                // Generate IVs + SKDs
                llc_iv_skd_rand_gen(link_id);
                // wait for IVs and SKDs generation
                llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_IVS_SKDS_GEN);
                // clear LLCP exchange Timer
                llc_proc_timer_set(link_id, LLC_PROC_REMOTE, false);
            } break;

            /*
             * @startuml
             * title : IVs & SKDs generated (WAIT_IVS_SKDS_GEN)
             * participant HCI
             * participant LLM
             * participant LLC
             * participant LLD
             * LLM--> LLC: LLM_ENCRYPT_RSP
             * LLC -> LLC: llm_encrypt_rsp_handler()
             * note over LLC: Store computed IVs and SKDs
             * activate LLC
             *      LLC -> LLC: llc_rem_encrypt_proc_continue(IVS_SKDS_GEN)
             *      activate LLC
             *          alt HCI_LE_LTK_REQUEST_EVT not masked by host
             *              LLC --> LLD : LLCP_ENC_RSP(IVs, SKDs)
             *              hnote over LLC #aqua: state = WAIT_LTK
             *              LLC --> HCI : HCI_LE_LTK_REQUEST_EVT(RandN, Ediv)
             *          else HCI_LE_LTK_REQUEST_EVT not masked by host
             *              LLC --> LLD : LLCP_REJECT_IND[_EXT](PIN_CODE_MISSING)
             *          end
             *      deactivate LLC
             * deactivate LLC
             * @enduml
             */
            case LLC_REM_WAIT_IVS_SKDS_GEN:
            {
                // check if HCI event is mask or not
                if(llm_le_evt_mask_check(LE_EVT_MASK_LG_TR_KEY_REQ_EVT_BIT))
                {
                    // send LLCP_ENC_RSP pdu
                    llc_ll_enc_rsp_pdu_send(link_id, &(param->skd.skd[SKD_S_OFFSET]), &(param->iv.vect[IV_S_OFFSET]));
                    // send LTK Request
                    llc_hci_ltk_request_evt_send(link_id, param->enc_div, &(param->nb.nb[0]));
                    // Wait for encryption response
                    llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_LTK);
                }
                // if it cannot be sent to host, automatically reject the encryption request.
                else
                {
                    // send LLCP_REJECT_IND[_EXT] PDU
                    llc_ll_reject_ind_pdu_send(link_id, LL_ENC_REQ_OPCODE, CO_ERROR_PIN_MISSING,
                                                 llc_ll_reject_ind_ack_handler);
                    // Wait for PDU ACK
                    llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_ENC_REJECT_ACK);
                }
            } break;

            /*
             * @startuml
             * title : Wait for LTK from Host (WAIT_LTK)
             * participant HCI
             * participant LLM
             * participant LLC
             * participant LLD
             * alt Host not able to retrieve LTK
             *     HCI --> LLC: HCI_LE_LTK_REQ_NEG_REPLY_CMD
             *     LLC -> LLC: hci_le_ltk_req_neg_reply_cmd_handler()
             *     activate LLC
             *         HCI <-- LLC: HCI_CMP_EVT
             *         LLC -> LLC: llc_rem_encrypt_proc_continue(LTK)
             *         activate LLC
             *             hnote over LLC: REM_PROC = Idle
             *             LLC --> LLD : LLCP_REJECT_IND(PIN_CODE_MISSING)
             *         deactivate LLC
             *     deactivate LLC
             * else Host Able to retrieve LTK
             *     HCI --> LLC: HCI_LE_LTK_REQ_REPLY_CMD
             *     LLC -> LLC: hci_le_ltk_req_reply_cmd_handler()
             *     activate LLC
             *         note over LLC : Store LTK
             *         HCI <-- LLC: HCI_CMP_EVT
             *         LLC -> LLC: llc_rem_encrypt_proc_continue(LTK)
             *         activate LLC
             *             hnote over LLC #aqua: state = WAIT_SK
             *             note over LLC : Use HW AES to compute Session key
             *             LLC --> LLM : LLM_ENCRYPT_REQ
             *         deactivate LLC
             *     deactivate LLC
             * end
             * @enduml
             */
            case LLC_REM_WAIT_LTK:
            {
                if(status == CO_ERROR_NO_ERROR)
                {
                    // Generate session key using LTK and session key diversifier [SKDm, SKDs]
                    llc_sk_gen(link_id, &(param->key), &(param->skd));
                    // Wait for SK computation and Start encryption response
                    llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_SK);
                }
                else
                {
                    // send LLCP_REJECT_IND[_EXT] PDU
                    llc_ll_reject_ind_pdu_send(link_id, LL_ENC_REQ_OPCODE, CO_ERROR_PIN_MISSING,
                                                 llc_ll_reject_ind_ack_handler);
                    // Wait for PDU ACK
                    llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_ENC_REJECT_ACK);
                }
            } break;

            /*
             * @startuml
             * title : Wait for SK (WAIT_SK)
             * participant LLM
             * participant LLC
             * participant LLD
             * LLM --> LLC: LLM_ENCRYPT_RSP
             * LLC -> LLC: llm_encrypt_rsp_handler()
             * activate LLC
             *     note over LLC : Store computed Session key
             *     LLC -> LLC: llc_rem_encrypt_proc_continue(SK)
             *     activate LLC
             *     LLC -> LLD:  lld_con_enc_key_load(SK, IV)
             *     LLC -> LLD:  lld_con_rx_enc(on)
             *     hnote over LLC #aqua: state = WAIT_START_ENC_RSP
             *     LLC --> LLD: LLCP_START_ENC_REQ
             *     deactivate LLC
             * deactivate LLC
             * @enduml
             */
            case LLC_REM_WAIT_SK:
            {
                // Load encryption information
                lld_con_enc_key_load(link_id, &(param->key), &(param->iv));
                // Start RX Encryption flow
                lld_con_rx_enc(link_id, true);

                // send LLCP_START_ENC_REQ
                llc_ll_start_enc_req_pdu_send(link_id);

                // Wait for LLCP_START_ENC_RSP PDU
                llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_START_ENC_RSP);
                // start remote LLCP exchange Timer
                llc_proc_timer_set(link_id, LLC_PROC_REMOTE, true);

                // Encryption start procedure started
                SETB(llc_env_ptr->link_info, LLC_INFO_ENC_START, true);

            } break;

            /*
             * @startuml
             * title : Wait for LLCP_START_ENC_RSP (WAIT_START_ENC_RSP)
             * participant LLC
             * participant LLD
             * LLD --> LLC: LLD_START_ENC_RSP
             * LLC -> LLC: llm_encrypt_rsp_handler()
             * activate LLC
             *     LLC -> LLC: llc_rem_encrypt_proc_continue(START_ENC_RSP)
             *     activate LLC
             *     LLC -> LLD:  lld_con_tx_enc(on)
             *     hnote over LLC #aqua: state = LLC_REM_WAIT_START_ENC_RSP_ACK
             *     LLC --> LLD: LLCP_START_ENC_RSP
             *     deactivate LLC
             * deactivate LLC
             * @enduml
             */
            case LLC_REM_WAIT_START_ENC_RSP:
            {
                // clear remote LLCP exchange Timer
                llc_proc_timer_set(link_id, LLC_PROC_REMOTE, false);
                // Start TX Encryption flow
                lld_con_tx_enc(link_id, true);
                // Wait for LLCP_START_ENC_RSP TX ACK
                llc_proc_state_set(&param->proc, link_id, LLC_REM_WAIT_START_ENC_RSP_ACK);
                // send LLCP_START_ENC_RSP
                llc_ll_start_enc_rsp_pdu_send(link_id, llc_ll_start_enc_rsp_ack_handler);
            } break;

            /*
             * @startuml
             * title : Wait LLD_START_ENC_RSP TX ACK (WAIT_START_ENC_RSP_ACK)
             * participant HCI
             * participant LLC_LLCP
             * participant LLC
             * participant LLD
             * LLD --> LLC_LLCP: LLD_LLCP_TX_CFM
             * LLC_LLCP -> LLC_LLCP: lld_llcp_tx_cfm_handler()
             * activate LLC_LLCP
             *     LLC_LLCP -> LLC: ll_start_enc_rsp_ack_handler()
             *     activate LLC
             *         LLC -> LLC: llc_loc_encrypt_proc_continue(START_ENC_RSP_ACK)
             *         activate LLC
             *            note over LLC: Encryption procedure is finished
             *            LLC -> LLD: lld_con_data_flow_set(on)
             *            hnote over LLC : REM_PROC = Idle
             *            alt First encryption
             *                LLC --> HCI: HCI_ENC_CHG_EVT
             *            else Re-Encryption
             *                LLC --> HCI: HCI_ENC_KEY_REFRESH_CMP_EVT
             *            end
             *         deactivate LLC
             *     deactivate LLC
             * deactivate LLC_LLCP
             * @enduml
             */
            case LLC_REM_WAIT_START_ENC_RSP_ACK:
            {
                finished = true;
            } break;

            /*
             * @startuml
             * title : Wait LLD_REJECT_IND[_EXT] TX ACK (WAIT_ENC_REJECT_ACK)
             * participant HCI
             * participant LLC_LLCP
             * participant LLC
             * participant LLD
             * LLD --> LLC_LLCP: LLD_LLCP_TX_CFM
             * LLC_LLCP -> LLC_LLCP: lld_llcp_tx_cfm_handler()
             * activate LLC_LLCP
             *     LLC_LLCP -> LLC: ll_reject_ind_ack_handler()
             *     activate LLC
             *         LLC -> LLC: llc_loc_encrypt_proc_continue(ENC_REJECT_ACK)
             *         activate LLC
             *            note over LLC: Encryption procedure is finished
             *            hnote over LLC : REM_PROC = Idle
             *            LLC -> LLD: lld_con_data_flow_set(on)
             *         deactivate LLC
             *     deactivate LLC
             * deactivate LLC_LLCP
             * @enduml
             */
            case LLC_REM_WAIT_ENC_REJECT_ACK:
            {
                finished = true;
                status   = CO_ERROR_PIN_MISSING;
            } break;

           default:
           {
               status = CO_ERROR_UNSPECIFIED_ERROR;
               ASSERT_INFO(0, link_id, llc_proc_state_get(&param->proc));
           }
           break;
        }
    }

    if(finished)
    {
        // in case link can be continued
        if(!llc_is_disconnecting(link_id))
        {
            // Restore the Data Flow
            lld_con_data_flow_set(link_id, true);

            // Re-enable reception and transmission of all LLCPs
            llc_llcp_state_set(link_id, LLC_LLCP_DIR_BOTH, LLC_LLCP_IDLE);

            // Send HCI_ENC_CHG_EVT or HCI_ENC_KEY_REFRESH_CMP_EVT
            if((status == CO_ERROR_NO_ERROR) || param->re_encrypt)
            {
                llc_hci_enc_evt_send(link_id, status, param->re_encrypt);
            }

            // mark link encrypted or not
            SETB(llc_env_ptr->link_info, LLC_INFO_LINK_ENCRYPTED, (status == CO_ERROR_NO_ERROR));

            // Start the LE_PING feature
            llc_le_ping_restart(link_id);

            // resume state of on-going local procedure ...
            llc_proc_timer_pause_set(link_id, LLC_PROC_LOCAL, false);
        }

        // unregister procedure
        llc_proc_unreg(link_id, LLC_PROC_REMOTE);

        // Encryption start procedure finished
        SETB(llc_env_ptr->link_info, LLC_INFO_ENC_START, false);
    }
}

/**
 ****************************************************************************************
 * @brief Call back definition of the function that can handle result of an AES based algorithm
 *
 * @param[in] status       Execution status
 * @param[in] aes_res      16 bytes block result
 * @param[in] link_id      The link Identifier
 ****************************************************************************************
 */
__STATIC void llc_aes_res_cb(uint8_t status, const uint8_t* aes_res, uint32_t link_id)
{
    // send message with result data
    struct llc_encrypt_ind* msg = KE_MSG_ALLOC(LLC_ENCRYPT_IND, KE_BUILD_ID(TASK_LLC, link_id),
                                                KE_BUILD_ID(TASK_LLC, link_id), llc_encrypt_ind);
    msg->status = status;
    memcpy(msg->result, aes_res, KEY_LEN);
    ke_msg_send(msg);
}


/**
 ****************************************************************************************
 * @brief Request Random Number generation using HW aes block.
 * used to generate Session key diversifier and Initialization vector
 *
 * @param[in] link_id       The link Identifier
 ****************************************************************************************
 */
__STATIC void llc_iv_skd_rand_gen(uint8_t link_id)
{
    // Request a randomization to be perform with AES
    aes_rand(llc_aes_res_cb, link_id);
}

/**
 ****************************************************************************************
 * @brief Request Session Key generation using HW aes block.
 *
 * @param[in] link_id       The link Identifier
 * @param[in] ltk           Long Term Key
 * @param[in] skd           Session Key diversifier
 ****************************************************************************************
 */
__STATIC void llc_sk_gen(uint8_t link_id, struct ltk* ltk,  struct sess_k_div *skd)
{
    // Request AES encryption to be performed
    aes_encrypt((uint8_t*)ltk, (uint8_t*)skd, true, llc_aes_res_cb, link_id);
}

/**
 ****************************************************************************************
 * @brief Sends the pause encryption request pdu.
 *
 * This function allocates an sets header and parameters of the pdu before pushing it in
 * the tx queue.
 *
 * @param[in] link_id       The link ID on which the LLCP has to be transmitted.
 ****************************************************************************************
 */
__STATIC void llc_ll_pause_enc_req_pdu_send(uint8_t link_id)
{
    struct ll_pause_enc_req pdu;
    pdu.op_code = LL_PAUSE_ENC_REQ_OPCODE;

    llc_llcp_send(link_id, (union llcp_pdu*) &pdu, NULL);
}

/**
 ****************************************************************************************
 * @brief Sends the pause encryption response pdu.
 *
 * This function allocates an sets header and parameters of the pdu before pushing it in
 * the tx queue.
 *
 * @param[in] link_id       The link ID on which the LLCP has to be transmitted.
 ****************************************************************************************
 */
__STATIC void llc_ll_pause_enc_rsp_pdu_send(uint8_t link_id, llc_llcp_tx_cfm_cb cfm_cb)
{
    struct ll_pause_enc_rsp pdu;
    pdu.op_code = LL_PAUSE_ENC_RSP_OPCODE;

    llc_llcp_send(link_id, (union llcp_pdu*) &pdu, cfm_cb);
}

/**
 ****************************************************************************************
 * @brief Sends the encryption request pdu.
 *
 * @param[in] link_id       The link ID on which the LLCP has to be transmitted.
 * @param[in] ediv          Encryption diversifier
 * @param[in] rand          Link Key Random Number
 * @param[in] skdm          Session key diversifier master
 * @param[in] ivm           Initiator vector master
 ****************************************************************************************
 */
__STATIC void llc_ll_enc_req_pdu_send(uint8_t link_id, uint16_t ediv, uint8_t* rand, uint8_t* skdm, uint8_t* ivm)
{
    struct ll_enc_req pdu;
    pdu.op_code = LL_ENC_REQ_OPCODE;
    pdu.ediv    = ediv;
    memcpy((uint8_t*)&(pdu.rand), rand, RAND_NB_LEN);      // Rand
    memcpy((uint8_t*)&(pdu.skdm), skdm, SESS_KEY_DIV_LEN); // SKDm
    memcpy((uint8_t*)&(pdu.ivm),  ivm,  INIT_VECT_LEN);    // IVm

    llc_llcp_send(link_id, (union llcp_pdu*) &pdu, NULL);
}

/**
 ****************************************************************************************
 * @brief Sends the encryption response pdu.
 *
 * This function allocates an sets header and parameters of the pdu before pushing it in
 * the tx queue.
 *
 * @param[in] link_id       The link ID on which the LLCP has to be transmitted.
 * @param[in] skds          Session key diversifier slave
 * @param[in] ivs           Initiator vector slave
 ****************************************************************************************
 */
__STATIC void llc_ll_enc_rsp_pdu_send(uint8_t link_id, uint8_t* skds, uint8_t* ivs)
{
    struct ll_enc_rsp pdu;
    pdu.op_code = LL_ENC_RSP_OPCODE;

    memcpy((uint8_t*)&(pdu.skds), skds, SESS_KEY_DIV_LEN); // SKDs
    memcpy((uint8_t*)&(pdu.ivs),  ivs,  INIT_VECT_LEN);    // IVs

    llc_llcp_send(link_id, (union llcp_pdu*) &pdu, NULL);
}

/**
 ****************************************************************************************
 * @brief Sends the start encryption request pdu.
 *
 * This function allocates an sets header and parameters of the pdu before pushing it in
 * the tx queue.
 *
 * @param[in] link_id       The link ID on which the LLCP has to be transmitted.
 ****************************************************************************************
 */
__STATIC void llc_ll_start_enc_req_pdu_send(uint8_t link_id)
{
    struct ll_start_enc_req pdu;
    pdu.op_code = LL_START_ENC_REQ_OPCODE;

    llc_llcp_send(link_id, (union llcp_pdu*) &pdu, NULL);
}

/**
 ****************************************************************************************
 * @brief Sends the start encryption response pdu.
 *
 * This function allocates an sets header and parameters of the pdu before pushing it in
 * the tx queue.
 *
 * @param[in] link_id       The link ID on which the LLCP has to be transmitted.
 * @param[in] cfm_cb        TX Baseband ACK callback
 ****************************************************************************************
 */
__STATIC void llc_ll_start_enc_rsp_pdu_send(uint8_t link_id, llc_llcp_tx_cfm_cb cfm_cb)
{
    struct ll_start_enc_rsp pdu;
    pdu.op_code = LL_START_ENC_RSP_OPCODE;

    llc_llcp_send(link_id, (union llcp_pdu*) &pdu, cfm_cb);
}




/**
 ****************************************************************************************
 * @brief Callback called when LLCP_PAUSE_ENC_RSP Tx Ack is received
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] op_code        LLCP operation code
 ****************************************************************************************
 */
__STATIC void llc_ll_pause_enc_rsp_ack_handler(uint8_t link_id, uint8_t op_code)
{
    if (llc_proc_id_get(link_id, LLC_PROC_LOCAL) == LLC_PROC_ENCRYPT)
    {
        llc_loc_encrypt_proc_continue(link_id, LLC_LOC_WAIT_PAUSE_ENC_RSP_ACK, CO_ERROR_NO_ERROR);
    }
}

/**
 ****************************************************************************************
 * @brief Callback called when LLCP_START_ENC_RSP Tx Ack is received
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] op_code        LLCP operation code
 ****************************************************************************************
 */
__STATIC void llc_ll_start_enc_rsp_ack_handler(uint8_t link_id, uint8_t op_code)
{
    if (llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT)
    {
        llc_rem_encrypt_proc_continue(link_id, LLC_REM_WAIT_START_ENC_RSP_ACK, CO_ERROR_NO_ERROR);
    }
}

/**
 ****************************************************************************************
 * @brief Callback called when LLCP_REJECT_IND Tx Ack is received
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] op_code        LLCP operation code
 ****************************************************************************************
 */
__STATIC void llc_ll_reject_ind_ack_handler(uint8_t link_id, uint8_t op_code)
{
    if (llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT)
    {
        llc_rem_encrypt_proc_continue(link_id, LLC_REM_WAIT_ENC_REJECT_ACK, CO_ERROR_NO_ERROR);
    }
}


/**
 ****************************************************************************************
 * @brief Send HCI_LTK_REQUEST_EVT to host
 *
 * @param[in] link_id        Link identifier
 * @param[in] enc_div        Encryption key diversifier
 * @param[in] randnb         Encryption random number
 ****************************************************************************************
 */
__STATIC void llc_hci_ltk_request_evt_send(uint8_t link_id, uint16_t enc_div, uint8_t* randnb)
{
    uint16_t conhdl = BLE_LINKID_TO_CONHDL(link_id);

    // allocate the status event message
    struct hci_le_ltk_request_evt *event = KE_MSG_ALLOC(HCI_LE_EVENT, conhdl, 0, hci_le_ltk_request_evt);
    // gets event subcode
    event->subcode = HCI_LE_LTK_REQUEST_EVT_SUBCODE;
    // gets connection handle
    event->conhdl  = conhdl;
    // gets encrypted diversifier
    event->ediv    = enc_div;
    // gets random number
    memcpy(&event->rand.nb[0], randnb, RAND_NB_LEN);
    // send the message
    hci_send_2_host(event);
}


/**
 ****************************************************************************************
 * @brief Send HCI_ENC_CHG_EVT or HCI_ENC_KEY_REFRESH_CMP_EVT to host
 *
 * @param[in] link_id        Link identifier
 * @param[in] status         Status of Encryption procedure
 * @param[in] re_encrypt     True if encryption key refresh, false else
 ****************************************************************************************
 */
__STATIC void llc_hci_enc_evt_send(uint8_t link_id, uint8_t status, bool re_encrypt)
{
    uint16_t conhdl = BLE_LINKID_TO_CONHDL(link_id);

    // if encryption state changes due to encryption start
    if(!re_encrypt)
    {
        // allocates the message to send
        struct hci_enc_change_evt *enc_chg = KE_MSG_ALLOC(HCI_EVENT, conhdl, HCI_ENC_CHG_EVT_CODE, hci_enc_change_evt);
        enc_chg->conhdl     = conhdl;
        enc_chg->enc_stat   = (status == CO_ERROR_NO_ERROR) ? ENC_BRDER_E0_LE_AESCCM : ENC_OFF;
        enc_chg->status     = status;
        hci_send_2_host(enc_chg);
    }
    else
    {
        // allocates the message to send
        struct hci_enc_key_ref_cmp_evt *enc_refresh = KE_MSG_ALLOC(HCI_EVENT, conhdl, HCI_ENC_KEY_REFRESH_CMP_EVT_CODE, hci_enc_key_ref_cmp_evt);
        enc_refresh->conhdl = conhdl;
        enc_refresh->status = status;
        hci_send_2_host(enc_refresh);
    }
}


/**
 * Local procedure callback used to inform if an unexpected error is raised during procedure execution
 *
 * @param[in] link_id     Link Identifier
 * @param[in] error_type  Error type (@see enum llc_error_type)
 * @param[in] param       Parameter according to error type:
 *   - LLC_ERR_DISCONNECT:          reason
 *   - LLC_ERR_LLCP_UNKNOWN_RSP:    struct ll_unknown_rsp*
 *   - LLC_ERR_LLCP_REJECT_IND:     struct ll_reject_ind*
 *   - LLC_ERR_LLCP_REJECT_IND_EXT: struct ll_reject_ext_ind*
 */
__STATIC void llc_loc_encrypt_proc_err_cb(uint8_t link_id, uint8_t error_type, void* param)
{
    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];

    switch(error_type)
    {
        // link disconnection occurs
        case LLC_ERR_DISCONNECT:
        {
            uint8_t reason = *((uint8_t*) param);
            llc_loc_encrypt_proc_continue(link_id, LLC_LOC_ENC_ERROR, reason);
        } break;
        case LLC_ERR_LLCP_UNKNOWN_RSP:
        {
            struct ll_unknown_rsp* rsp = (struct ll_unknown_rsp*) param;
            // only LLCP_ENC_REQ and LLCP_PAUSE_ENC_REQ can receive unknown response. Others will automatically
            // generates a MIC failure.
            if ((rsp->unk_type == LL_ENC_REQ_OPCODE) || (rsp->unk_type == LL_PAUSE_ENC_REQ_OPCODE))
            {
                llc_loc_encrypt_proc_continue(link_id, LLC_LOC_ENC_ERROR, CO_ERROR_UNSUPPORTED_REMOTE_FEATURE);
            }
        } break;
        case LLC_ERR_LLCP_REJECT_IND_EXT:
        {
            struct ll_reject_ext_ind* reject_ext = (struct ll_reject_ext_ind*) param;
            if(reject_ext->rej_op_code == LL_ENC_REQ_OPCODE)
            {
                llc_loc_encrypt_proc_continue(link_id, LLC_LOC_ENC_ERROR, reject_ext->err_code);
            }
            else
            {
                if(GETF(llc_env_ptr->llcp_state, LLC_LLCP_RX) != LLC_LLCP_IDLE)
                {
                    llc_loc_encrypt_proc_continue(link_id, LLC_LOC_ENC_ERROR, CO_ERROR_TERMINATED_MIC_FAILURE);
                }
            }
        } break;
        case LLC_ERR_LLCP_REJECT_IND:
        {
            struct ll_reject_ind* reject = (struct ll_reject_ind*) param;
            llc_loc_encrypt_proc_continue(link_id, LLC_LOC_ENC_ERROR, reject->err_code);
        } break;
        default:
        {
            // not expected at all
            ASSERT_INFO(0, link_id, error_type);
        } break;
    }
}

/**
 * Remote procedure callback used to inform if an unexpected error is raised during procedure execution
 *
 * @param[in] link_id     Link Identifier
 * @param[in] error_type  Error type (@see enum llc_error_type)
 * @param[in] param       Parameter according to error type:
 *   - LLC_ERR_DISCONNECT:          reason
 *   - LLC_ERR_LLCP_UNKNOWN_RSP:    struct ll_unknown_rsp*
 *   - LLC_ERR_LLCP_REJECT_IND:     struct ll_reject_ind*
 *   - LLC_ERR_LLCP_REJECT_IND_EXT: struct ll_reject_ext_ind*
 */
__STATIC void llc_rem_encrypt_proc_err_cb(uint8_t link_id, uint8_t error_type, void* param)
{
    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    switch(error_type)
    {
        // link is disconnected, stop procedure according to reason
        case LLC_ERR_DISCONNECT:
        {
            uint8_t reason = *((uint8_t*) param);
            llc_rem_encrypt_proc_continue(link_id, LLC_REM_ENC_ERROR, reason);
        } break;
        case LLC_ERR_LLCP_UNKNOWN_RSP:
        case LLC_ERR_LLCP_REJECT_IND:
        case LLC_ERR_LLCP_REJECT_IND_EXT:
        {
            // check if link should be disconnected
            if(GETF(llc_env_ptr->llcp_state, LLC_LLCP_RX) != LLC_LLCP_IDLE)
            {
                llc_rem_encrypt_proc_continue(link_id, LLC_REM_ENC_ERROR, CO_ERROR_TERMINATED_MIC_FAILURE);
            } // or ignore the event
        } break;
        default:
        {
            // not expected at all
            ASSERT_INFO(0, link_id, error_type);
        } break;
    }
}


/*
 * EXPORTED FUNCTIONS DEFINITIONS
 ****************************************************************************************
 */

/*
 ****************************************************************************************
 * LLCP Handlers
 ****************************************************************************************
 */

/**
 ****************************************************************************************
 *  @brief Handles the reception of a LLCP pause encryption request
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] pdu            LLCP PDU information received
 * @param[in] event_cnt      Event counter value when PDU has been received
 *
 * @return status code of handler:
 *    - CO_ERROR_NO_ERROR:               Nothing more to do
 *    - CO_ERROR_TERMINATED_MIC_FAILURE: Immediately disconnect the link
 *    - others:                          Send an LLCP_REJECT_IND or LLCP_REJECT_IND_EXT
 ****************************************************************************************
 */
uint8_t ROM_VT_FUNC(ll_pause_enc_req_handler)(uint8_t link_id, struct ll_pause_enc_req *pdu, uint16_t event_cnt)
{
    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    uint8_t status = CO_ERROR_NO_ERROR;

    // This LLCP request shall be issued by the master only
    if (GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE))
    {
        // unexpected message, reject it.
        status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
    }
    else
    {
        if(llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_NONE)
        {
            // prepare remote encryption procedure information
            struct llc_op_encrypt_ind * enc_op = KE_MSG_ALLOC(LLC_OP_ENCRYPT_IND, TASK_LLC, TASK_LLC, llc_op_encrypt_ind);
            llc_proc_init(&enc_op->proc, LLC_PROC_ENCRYPT, llc_rem_encrypt_proc_err_cb);
            llc_proc_state_set(&enc_op->proc, link_id, LLC_REM_ENC_PROC_START);
            enc_op->re_encrypt    = true;
            // register procedure
            llc_proc_reg(link_id, LLC_PROC_REMOTE, &(enc_op->proc));

            // enter in state handler of remote encryption state machine
            llc_rem_encrypt_proc_continue(link_id, LLC_REM_ENC_PROC_START, CO_ERROR_NO_ERROR);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    return (status);
}

/**
 ****************************************************************************************
 *  @brief Handles the reception of a LLCP pause encryption response
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] pdu            LLCP PDU information received
 * @param[in] event_cnt      Event counter value when PDU has been received
 *
 * @return status code of handler:
 *    - CO_ERROR_NO_ERROR:               Nothing more to do
 *    - CO_ERROR_TERMINATED_MIC_FAILURE: Immediately disconnect the link
 *    - others:                          Send an LLCP_REJECT_IND or LLCP_REJECT_IND_EXT
 ****************************************************************************************
 */
uint8_t ROM_VT_FUNC(ll_pause_enc_rsp_handler)(uint8_t link_id, struct ll_pause_enc_rsp *pdu, uint16_t event_cnt)
{
    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    uint8_t status = CO_ERROR_NO_ERROR;

    // pause request initiated by local device
    // Check if we are allowed to receive this packet
    if (GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE)
            && (llc_proc_id_get(link_id, LLC_PROC_LOCAL) == LLC_PROC_ENCRYPT))
    {
        // enter in state handler of local initiated encryption state machine
        llc_loc_encrypt_proc_continue(link_id, LLC_LOC_WAIT_PAUSE_ENC_RSP, CO_ERROR_NO_ERROR);
    }

    // pause request initiated by local device
    // Check if we are allowed to receive this packet
    else if (!GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE)
            && (llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT))
    {
        // enter in state handler of remote initiated encryption state machine
        llc_rem_encrypt_proc_continue(link_id, LLC_REM_WAIT_PAUSE_ENC_RSP, CO_ERROR_NO_ERROR);
    }
    else
    {
        status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
    }
    return (status);
}

/**
 ****************************************************************************************
 *  @brief Handles the reception of a LLCP encryption request
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] pdu            LLCP PDU information received
 * @param[in] event_cnt      Event counter value when PDU has been received
 *
 * @return status code of handler:
 *    - CO_ERROR_NO_ERROR:               Nothing more to do
 *    - CO_ERROR_TERMINATED_MIC_FAILURE: Immediately disconnect the link
 *    - others:                          Send an LLCP_REJECT_IND or LLCP_REJECT_IND_EXT
 ****************************************************************************************
 */
uint8_t ROM_VT_FUNC(ll_enc_req_handler)(uint8_t link_id, struct ll_enc_req *pdu, uint16_t event_cnt)
{
    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    uint8_t status = CO_ERROR_NO_ERROR;

    // This LLCP request shall be issued by the master only
    if (GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE))
    {
        // Local encryption on-going, MIC failure
        if (llc_proc_id_get(link_id, LLC_PROC_LOCAL) == LLC_PROC_ENCRYPT)
        {
            llc_loc_encrypt_proc_continue(link_id, LLC_LOC_ENC_ERROR, CO_ERROR_TERMINATED_MIC_FAILURE);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    else
    {
        struct llc_op_encrypt_ind * param = NULL;
        uint8_t state = LLC_REM_WAIT_ENC_REQ;

        // Encryption Procedure to be started
        if(llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_NONE)
        {
            // prepare remote encryption procedure information
            param = KE_MSG_ALLOC(LLC_OP_ENCRYPT_IND, TASK_LLC, TASK_LLC, llc_op_encrypt_ind);
            llc_proc_init(&param->proc, LLC_PROC_ENCRYPT, llc_rem_encrypt_proc_err_cb);
            param->re_encrypt    = false;
            // register procedure
            llc_proc_reg(link_id, LLC_PROC_REMOTE, &(param->proc));
            // update the local state
            llc_proc_state_set(&(param->proc), link_id, LLC_REM_ENC_PROC_START);
            state = LLC_REM_ENC_PROC_START;
        }
        // Continue Encryption Procedure
        if(llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT)
        {
            param = (struct llc_op_encrypt_ind*)llc_proc_get(link_id, LLC_PROC_REMOTE);
            // Copy provided IVm, SKDm RandNB and e_div
            param->enc_div       = pdu->ediv;
            memcpy(&(param->iv.vect[IV_M_OFFSET]),  &(pdu->ivm),  INIT_VECT_LEN);
            memcpy(&(param->skd.skd[SKD_M_OFFSET]), &(pdu->skdm), SESS_KEY_DIV_LEN);
            memcpy(&(param->nb.nb[0]),              &(pdu->rand), RAND_NB_LEN);

            llc_rem_encrypt_proc_continue(link_id, state, CO_ERROR_NO_ERROR);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    return (status);
}


/**
 ****************************************************************************************
 * @brief Handles the reception of a LLCP encryption response
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] pdu            LLCP PDU information received
 * @param[in] event_cnt      Event counter value when PDU has been received
 *
 * @return status code of handler:
 *    - CO_ERROR_NO_ERROR:               Nothing more to do
 *    - CO_ERROR_TERMINATED_MIC_FAILURE: Immediately disconnect the link
 *    - others:                          Send an LLCP_REJECT_IND or LLCP_REJECT_IND_EXT
 ****************************************************************************************
 */
uint8_t ROM_VT_FUNC(ll_enc_rsp_handler)(uint8_t link_id, struct ll_enc_rsp *pdu, uint16_t event_cnt)
{
    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    uint8_t status = CO_ERROR_NO_ERROR;

    // This LLCP request shall be issued by the slave only
    if (!GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE))
    {
        // Remote encryption on-going, MIC failure
        if (llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT)
        {
            llc_rem_encrypt_proc_continue(link_id, LLC_REM_ENC_ERROR, CO_ERROR_TERMINATED_MIC_FAILURE);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    else
    {
        struct llc_op_encrypt_ind* param = NULL;

        // Continue Encryption Procedure
        if(llc_proc_id_get(link_id, LLC_PROC_LOCAL) == LLC_PROC_ENCRYPT)
        {
            param = (struct llc_op_encrypt_ind*) llc_proc_get(link_id, LLC_PROC_LOCAL);
            // Copy provided IVs and SKDs
            memcpy(&(param->iv.vect[IV_S_OFFSET]),  &(pdu->ivs),  INIT_VECT_LEN);
            memcpy(&(param->skd.skd[SKD_S_OFFSET]), &(pdu->skds), SESS_KEY_DIV_LEN);

            llc_loc_encrypt_proc_continue(link_id, LLC_LOC_WAIT_ENC_RSP, CO_ERROR_NO_ERROR);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    return (status);
}


/**
 ****************************************************************************************
 * @brief Handles the reception of a LLCP start encryption request
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] pdu            LLCP PDU information received
 * @param[in] event_cnt      Event counter value when PDU has been received
 *
 * @return status code of handler:
 *    - CO_ERROR_NO_ERROR:               Nothing more to do
 *    - CO_ERROR_TERMINATED_MIC_FAILURE: Immediately disconnect the link
 *    - others:                          Send an LLCP_REJECT_IND or LLCP_REJECT_IND_EXT
 ****************************************************************************************
 */
uint8_t ROM_VT_FUNC(ll_start_enc_req_handler)(uint8_t link_id, struct ll_start_enc_req *pdu, uint16_t event_cnt)
{
    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    uint8_t status = CO_ERROR_NO_ERROR;

    // This LLCP request shall be issued by the slave only
    if (!GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE))
    {
        // Remote encryption on-going, MIC failure
        if (llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT)
        {
            llc_rem_encrypt_proc_continue(link_id, LLC_REM_ENC_ERROR, CO_ERROR_TERMINATED_MIC_FAILURE);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    else
    {
        // Continue Encryption Procedure
        if(llc_proc_id_get(link_id, LLC_PROC_LOCAL) == LLC_PROC_ENCRYPT)
        {
            llc_loc_encrypt_proc_continue(link_id, LLC_LOC_WAIT_START_ENC_REQ, CO_ERROR_NO_ERROR);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    return (status);
}


/**
 ****************************************************************************************
 * @brief Handles the reception of a LLCP start encryption response
 *
 * @param[in] link_id        Link identifier on which the pdu will be sent.
 * @param[in] pdu            LLCP PDU information received
 * @param[in] event_cnt      Event counter value when PDU has been received
 *
 * @return status code of handler:
 *    - CO_ERROR_NO_ERROR:               Nothing more to do
 *    - CO_ERROR_TERMINATED_MIC_FAILURE: Immediately disconnect the link
 *    - others:                          Send an LLCP_REJECT_IND or LLCP_REJECT_IND_EXT
 ****************************************************************************************
 */
uint8_t ROM_VT_FUNC(ll_start_enc_rsp_handler)(uint8_t link_id, struct ll_start_enc_rsp *pdu, uint16_t event_cnt)
{

    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];
    uint8_t status = CO_ERROR_NO_ERROR;

    // This LLCP can be issued by both Master and slave
    if (!GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE))
    {
        // Remote encryption on-going, MIC failure
        if (llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT)
        {
            llc_rem_encrypt_proc_continue(link_id, LLC_REM_WAIT_START_ENC_RSP, CO_ERROR_NO_ERROR);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    else
    {
        // Continue Encryption Procedure
        if(llc_proc_id_get(link_id, LLC_PROC_LOCAL) == LLC_PROC_ENCRYPT)
        {
            llc_loc_encrypt_proc_continue(link_id, LLC_LOC_WAIT_START_ENC_RSP, CO_ERROR_NO_ERROR);
        }
        else
        {
            status = CO_ERROR_LMP_PDU_NOT_ALLOWED;
        }
    }
    return (status);
}


/*
 ****************************************************************************************
 * HCI Handlers
 ****************************************************************************************
 */


/**
 ****************************************************************************************
 * @brief Handles request from host to enable encryption of the link or re-encryption of the link
 *
 * PlantUML procedure description
 *
 * @startuml
 * title : Encryption procedure initiated by host
 * participant HCI
 * participant LLC
 * HCI --> LLC : HCI_LE_EN_ENC_CMD
 * LLC -> LLC: hci_le_en_enc_cmd_handler()
 * activate LLC
 * alt link disconnected \nor slave \nor peer not support encryption
 *     LLC --> HCI : HCI_CMD_STAT_EVENT(DISALLOWED)
 * else  Procedure already started
 *     LLC --> HCI : HCI_CMD_STAT_EVENT(BUSY)
 * else  Procedure can be started
 *     note over LLC: Mark procedure started
 *     LLC --> LLC : LLC_OP_ENCRYPT_IND
 *     note right LLC #lightgreen: See __llc_op_encrypt_ind_handler()__
 *     LLC --> HCI : HCI_CMD_STAT_EVENT(OK)
 * end
 * deactivate LLC
 * @enduml
 *
 * @param[in] link_id Link Identifier
 * @param[in] param   Pointer to the parameters of the message.
 * @param[in] opcode  HCI Operation code
 * @return If the message was consumed or not.
 ****************************************************************************************
 */
int ROM_VT_FUNC(hci_le_en_enc_cmd_handler)(uint8_t link_id, struct hci_le_en_enc_cmd const *param, uint16_t opcode)
{
    // Command status
    uint8_t status = CO_ERROR_NO_ERROR;
    //Get environment pointer
    struct llc_env_tag *llc_env_ptr = llc_env[link_id];

    // check if state is Free or in disconnected state or Slave device
    if(llc_is_disconnecting(link_id) || !GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE))
    {
        status = CO_ERROR_COMMAND_DISALLOWED;
    }
    // check if peer support this feature
    else if(!llc_le_feature_check(link_id, BLE_FEAT_ENC))
    {
        status = CO_ERROR_UNSUPPORTED_REMOTE_FEATURE;
    }
    // ensure that host not currently processing request
    else if(GETB(llc_env_ptr->flow_ctrl, LLC_HCI_START_ENCRYPT_REQ))
    {
        status = CO_ERROR_CONTROLLER_BUSY;
    }
    #if (BLE_CIS)
    // If the Connection_Handle parameter identifies an ACL with an associated CIS that has been created
    else if(lli_cis_is_present(link_id))
    {
        status = CO_ERROR_COMMAND_DISALLOWED;
    }
    #endif // (BLE_CIS)
    else
    {
        ke_task_id_t llc_id = KE_BUILD_ID(TASK_LLC, link_id);

        // prepare local encryption procedure
        struct llc_op_encrypt_ind * enc_op = KE_MSG_ALLOC(LLC_OP_ENCRYPT_IND, llc_id, llc_id, llc_op_encrypt_ind);
        llc_proc_init(&enc_op->proc, LLC_PROC_ENCRYPT, llc_loc_encrypt_proc_err_cb);
        llc_proc_state_set(&enc_op->proc, link_id, LLC_LOC_ENC_PROC_START);
        memcpy(&enc_op->nb.nb[0],  &param->nb.nb[0],  RAND_NB_LEN);
        enc_op->enc_div       = param->enc_div;
        memcpy(&enc_op->key.ltk[0],  &param->ltk.ltk[0],  KEY_LEN);
        // check if we encrypt or re-encrypt the link
        enc_op->re_encrypt    = GETB(llc_env_ptr->link_info, LLC_INFO_LINK_ENCRYPTED);

        ke_msg_send(enc_op);

        // Mark Encryption procedure started and waiting to be granted.
        SETB(llc_env_ptr->flow_ctrl, LLC_HCI_START_ENCRYPT_REQ, true);
    }

    // Send the command status event
    llc_cmd_stat_send(link_id, opcode, status);

    return (KE_MSG_CONSUMED);
}

/**
 ****************************************************************************************
 * @brief Handles HCI message providing Long Term Key for that connection
 *
 * @param[in] link_id Link Identifier
 * @param[in] param   Pointer to the parameters of the message.
 * @param[in] opcode  HCI Operation code
 * @return If the message was consumed or not.
 ****************************************************************************************
 */
int ROM_VT_FUNC(hci_le_ltk_req_reply_cmd_handler)(uint8_t link_id, struct hci_le_ltk_req_reply_cmd const *cmd, uint16_t opcode)
{
    uint8_t status = CO_ERROR_COMMAND_DISALLOWED;

    // check if state is Free or in disconnected state
    if(llc_is_disconnecting(link_id))
    {
        // Nothing to do
    }
    // check if Remote procedure is on-going
    else if(llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT)
    {
        struct llc_op_encrypt_ind* param = (struct llc_op_encrypt_ind*) llc_proc_get(link_id, LLC_PROC_REMOTE);

        if(llc_proc_state_get(&param->proc) == LLC_REM_WAIT_LTK)
        {
            status = CO_ERROR_NO_ERROR;
            // Copy the LTK
            memcpy(&param->key.ltk[0], &cmd->ltk.ltk[0], KEY_LEN);
            // continue procedure execution
            llc_rem_encrypt_proc_continue(link_id, LLC_REM_WAIT_LTK, CO_ERROR_NO_ERROR);
        }
    }

    // Send the command complete event
    llc_cmd_cmp_send(link_id, opcode, status);

    return (KE_MSG_CONSUMED);
}
/**
 ****************************************************************************************
 * @brief Handles HCI message informing that host has not the Long Term Key for that connection
 *
 * @param[in] link_id Link Identifier
 * @param[in] param   Pointer to the parameters of the message.
 * @param[in] opcode  HCI Operation code
 * @return If the message was consumed or not.
 ****************************************************************************************
 */
int ROM_VT_FUNC(hci_le_ltk_req_neg_reply_cmd_handler)(uint8_t link_id, struct hci_le_ltk_req_neg_reply_cmd const *param, uint16_t opcode)
{
    uint8_t status = CO_ERROR_COMMAND_DISALLOWED;

    // check if state is Free or in disconnected state
    if(llc_is_disconnecting(link_id))
    {
        // Nothing to do
    }
    // check if Remote procedure is on-going
    else if(llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT)
    {
        struct llc_op_encrypt_ind* param = (struct llc_op_encrypt_ind*)llc_proc_get(link_id, LLC_PROC_REMOTE);

        if(llc_proc_state_get(&param->proc) == LLC_REM_WAIT_LTK)
        {
            status = CO_ERROR_NO_ERROR;

            // If the Host does not provide a Long Term Key, because it indicates that
            // a key is not available the slave shall:
            //   1. If the Pause Encryption Procedure was executed before restarting
            //      the encryption, initiate the Termination Procedure
            //   2. Otherwise, send an LL_REJECT_IND PDU to abort the Encryption Start
            //      procedure
            // In both cases, the reason shall be set to PIN or key Missing.
            if(param->re_encrypt)
            {
                // unregister procedure
                llc_proc_unreg(link_id, LLC_PROC_REMOTE);

                // Encryption start procedure finished
                SETB(llc_env[link_id]->link_info, LLC_INFO_ENC_START, false);

                // Key refresh procedure is pending, so initiate the Termination Procedure
                llc_init_term_proc(link_id, CO_ERROR_PIN_MISSING);
            }
            else
            {
                // continue procedure execution
                llc_rem_encrypt_proc_continue(link_id, LLC_REM_WAIT_LTK, CO_ERROR_PIN_MISSING);
            }
        }
    }

    // Send the command complete event
    llc_cmd_cmp_send(link_id, opcode, status);

    return (KE_MSG_CONSUMED);
}

/*
 ****************************************************************************************
 * Local Messages Handlers
 ****************************************************************************************
 */


/**
 ****************************************************************************************
 * @brief Handles the AES128 encrypted data received.
 *
 * @param[in] msgid Id of the message received (probably unused).
 * @cmd[in] cmd Pointer to the parameters of the message.
 * @cmd[in] dest_id ID of the receiving task instance (probably unused).
 * @cmd[in] src_id ID of the sending task instance.
 * @return If the message was consumed or not.
 ****************************************************************************************
 */
int ROM_VT_FUNC(llc_encrypt_ind_handler)(ke_msg_id_t const msgid, struct llc_encrypt_ind const *ind,
                            ke_task_id_t const dest_id, ke_task_id_t const src_id)
{
    uint8_t link_id = KE_IDX_GET(dest_id);

    if(!llc_is_disconnecting(link_id))
    {
        struct llc_env_tag *llc_env_ptr = llc_env[link_id];
        struct llc_op_encrypt_ind* param = NULL;

        // Master role, local encryption procedure should be on-going
        if(GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE) // master
                && (llc_proc_id_get(link_id, LLC_PROC_LOCAL) == LLC_PROC_ENCRYPT))
        {
            // retrieve Local procedure parameters
            param = (struct llc_op_encrypt_ind*) llc_proc_get(link_id, LLC_PROC_LOCAL);
            switch(llc_proc_state_get(&param->proc))
            {
                case LLC_LOC_WAIT_IVM_SKDM_GEN:
                {
                    // Copy generated IVm and SKDm and put them in final IV/SKD
                    memcpy(&(param->iv.vect[IV_M_OFFSET]),   &(ind->result[0]),             INIT_VECT_LEN);
                    memcpy(&(param->skd.skd[SKD_M_OFFSET]),  &(ind->result[INIT_VECT_LEN]), SESS_KEY_DIV_LEN);
                } break;
                case LLC_LOC_WAIT_SK:
                {
                    // copy computed session key
                    memcpy(&(param->key.ltk[0]), &(ind->result[0]), KEY_LEN);
                } break;
                default:
                {
                   ASSERT_INFO(0, link_id, llc_proc_state_get(&param->proc));
                } break;
            }

            // continue local procedure execution
            llc_loc_encrypt_proc_continue(link_id, llc_proc_state_get(&param->proc), CO_ERROR_NO_ERROR);
        }
        else if(!GETB(llc_env_ptr->link_info, LLC_INFO_MASTER_ROLE) // Slave
                && (llc_proc_id_get(link_id, LLC_PROC_REMOTE) == LLC_PROC_ENCRYPT))
        {
            // retrieve Remote procedure parameters
            param = (struct llc_op_encrypt_ind*) llc_proc_get(link_id, LLC_PROC_REMOTE);
            switch(llc_proc_state_get(&param->proc))
            {
                case LLC_REM_WAIT_IVS_SKDS_GEN:
                {
                    // Copy generated IVm and SKDm and put them in final IV/SKD
                    memcpy(&(param->iv.vect[IV_S_OFFSET]),  &(ind->result[0]),             INIT_VECT_LEN);
                    memcpy(&(param->skd.skd[SKD_S_OFFSET]), &(ind->result[INIT_VECT_LEN]), SESS_KEY_DIV_LEN);
                } break;
                case LLC_REM_WAIT_SK:
                {
                    // copy computed session key
                    memcpy(&(param->key.ltk[0]), &(ind->result[0]), KEY_LEN);
                } break;
                default:
                {
                   ASSERT_INFO(0, link_id, llc_proc_state_get(&param->proc));
                } break;
            }

            // continue remote procedure execution
            llc_rem_encrypt_proc_continue(link_id, llc_proc_state_get(&param->proc), CO_ERROR_NO_ERROR);
        }
    }

    return(KE_MSG_CONSUMED);
}


/**
 ****************************************************************************************
 * @brief Handles the Encryption procedure indication message.
 *
 * PlantUML procedure description
 *
 * @startuml
 * title : Encryption procedure start
 * participant LLC
 *  --> LLC : LLC_OP_ENCRYPT_IND
 * LLC -> LLC: llc_op_encrypt_ind_handler()
 * activate LLC
 * hnote over LLC : LOC_PROC = Busy
 * LLC -> LLC: llc_loc_encrypt_proc_continue(START)
 * activate LLC
 * note right LLC #lightgreen: See __llc_loc_encrypt_proc_continue()__
 * deactivate LLC
 * deactivate LLC
 * @enduml
 *
 ****************************************************************************************
 */
int ROM_VT_FUNC(llc_op_encrypt_ind_handler)(ke_msg_id_t const msgid, struct llc_op_encrypt_ind *param,
                                ke_task_id_t const dest_id, ke_task_id_t const src_id)
{
    // Current message status
    int msg_status = KE_MSG_CONSUMED;
    uint8_t link_id = KE_IDX_GET(dest_id);

    // Check if state in disconnected state
    if(llc_is_disconnecting(link_id))
    {
        // disconnection on-going inform that command is aborted
        struct llc_env_tag *llc_env_ptr = llc_env[link_id];
        llc_hci_enc_evt_send(link_id, llc_env_ptr->disc_reason, false);
    }
    // check if another local procedure is on-going
    else if(llc_proc_id_get(link_id, LLC_PROC_LOCAL) != LLC_PROC_NONE)
    {
        // process this message later
        msg_status = KE_MSG_SAVED;
    }
    else
    {
        msg_status = KE_MSG_NO_FREE;

        // store local procedure
        llc_proc_reg(link_id, LLC_PROC_LOCAL, &(param->proc));
        // execute local Encryption procedure
        llc_loc_encrypt_proc_continue(link_id, LLC_LOC_ENC_PROC_START, CO_ERROR_NO_ERROR);
    }
    return (msg_status);
}

#endif // (BLE_CENTRAL || BLE_PERIPHERAL)

/// @} LLC_ENCRYPT
